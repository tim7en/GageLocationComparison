library (shiny)
library (leaflet)
library (RColorBrewer)
library (ggmap)
library (rmapshaper)
#library (foreign)
library (clipr)
library (e1071)
library (gridExtra)
library (labeling)
library (plogr)
library (readr)
library (reshape2)
library (viridisLite)
library (xfun)
library (shinyWidgets)

################
datas <- read.csv ("datas.csv", stringsAsFactors = F)
datas$numid <- datas$id
states <- read.csv ("states.csv", stringsAsFactors = F)
datas <- datas[-c(which(datas$state %in% c("HI", "PR", "GM", "GU", "AK"))),]
datas$dif_area_g3 <- abs(datas$area_nav - datas$area_g3)
datas$dif_area_nwis <- abs (datas$area_nav - (datas$area_nwis*2.58999))
datas$dif_area_g3nwis <- abs (datas$area_g3 - (datas$area_nwis * 2.58999))

classify_gages <- function (x, y){
  x$class <- 0
  x$class[which(x[y] >= 0 & x[y] <= 10)] <- 1
  x$class[which(x[y] >= 10 & x[y] <= 50)] <-2
  x$class[which(x[y] >= 50 & x[y] <= 300)] <-3
  x$class[which(x[y] >= 300 & x[y] <= 500)] <-4
  x$class[which(x[y] >= 500 & x[y] <= 1000)] <-5
  x$class[which(x[y] > 1000)] <- 6
  return (x)
}
################

################
datas_nldi <- data.frame (id = datas$id, lat = datas$lat_ss, long = datas$long_ss, proxy = datas$nldi_proxy, ds = "Nldi", state = datas$state, active = datas$active, numid = datas$numid)
datas_nldi <- classify_gages(datas_nldi, "proxy")

datas_g3 <- data.frame (id = datas$id, lat = datas$lat_g3, long = datas$long_g3, proxy = datas$gages3_proxy, ds = "gages3", state = datas$state, active = datas$active, numid = datas$numid)
datas_g3 <- classify_gages(datas_g3, "proxy")

datas_nav <- data.frame (id = datas$id, lat = datas$lat_nav, long = datas$long_nav, proxy = datas$nav_proxy, ds = "SSNav", state = datas$state, active = datas$active, numid = datas$numid)
datas_nav <- classify_gages(datas_nav, "proxy")

datas_nwis <- data.frame (id = datas$id, lat = datas$lat_nwis, long = datas$long_nwis, proxy = datas$nwis_proxy, ds = "Nwis", state = datas$state, active = datas$active, numid = datas$numid)
datas_nwis <- classify_gages(datas_nwis, "proxy")

datas_nhd <- data.frame (id = datas$id, lat = datas$lat_nhd, long = datas$long_nhd, proxy = datas$nhd_proxy, ds = "Nhd", state = datas$state, active = datas$active, numid = datas$numid)
datas_nhd <- classify_gages(datas_nhd, "proxy")

datas <- rbind (datas_g3, datas_nav, datas_nwis, datas_nldi, datas_nhd)
names (datas)[4] <- ("proxy_dist")

datas <- na.omit (datas)
datas_nldi <- na.omit (datas_nldi)
datas_nav <- na.omit (datas_nav)
datas_nwis <- na.omit (datas_nwis)
datas_g3 <- na.omit (datas_g3)
################

# #proximity difference between gages 
# length (which (datas_nldi$class == 6)) #>1000 
# length (which (datas_nav$class == 6))
# length (which (datas_nwis$class == 6))
# length (which (datas_g3$class == 6))
# 
# length (which (datas_nldi$class == 5)) #>500
# length (which (datas_nav$class == 5))
# length (which (datas_nwis$class == 5))
# length (which (datas_g3$class == 5))
# 
# length (which (datas_nldi$class == 4)) #>300
# length (which (datas_nav$class == 4))
# length (which (datas_nwis$class == 4))
# length (which (datas_g3$class == 4))



datas$id <- paste(datas$id, datas$ds, sep = "_")
datas$ds <- as.numeric (datas$ds)

ui <- bootstrapPage(
  tags$style(type = "text/css", 
             "html, body {width:100%;height:100%}",
  ),
  tags$head (includeCSS("style.css")),
  leafletOutput("map", width = "100%", height = "100%"),
  absolutePanel(id  = "controls", top = 30, right = 10, bottom = "auto",
                class = "panel panel-default",
                draggable = T,
                br(),
                "Specify class ranges",
                br(),
                br(),
                numericInput("lef", "Range 1:", 4, min = 1, max = 10),
                numericInput("righ", "Range 2:", 4, min = 1, max = 10),
                selectInput("colors", "Color Scheme",
                            rownames(subset(brewer.pal.info, category %in% c("seq", "div")))
                ),
                br (),
                searchInput(
                  inputId = "search", label = "Enter site number ex 06306000",
                  placeholder = "Site number",
                  btnSearch = icon("search"),
                  btnReset = icon("remove"),
                  width = "250px"
                ),
                checkboxInput("legend", "Show legend", TRUE),
                checkboxInput("activeGages", "Show only active gages", TRUE),
                uiOutput ("url_description"),
                uiOutput ("url_repo"),
                uiOutput ("url_mrd"),
                downloadButton("downloadData", "Download")
  )
)

server <- function(input, output, session) {
  datas_new <- reactiveValues()
  datas_new$datas <- datas
  
  # Reactive expression for the data subsetted to what the user selected
  filteredData <- reactive({
    if (input$activeGages){
      dat <- datas_new$datas[which(datas_new$datas$active == 1),] 
    } else {
      dat <- datas_new$datas
    }
    dat <- dat[dat$class >= input$lef & dat$class <= input$righ,]
    dat
  })
  
  url_repo <- a("Github", href="https://github.com/USGS-WiM/GageLocationComparison")
  output$url_repo <- renderUI({
    tagList("", url_repo)
  })
  
  url_description <- a("Description", href = "https://usgs-wim.github.io/GageLocationComparison/description.html")
  output$url_description <- renderUI({
    tagList("", url_description)
  })
  
  url_mrd <- a("How data generated ?", href = "https://usgs-wim.github.io/GageLocationComparison/gages.html")
  output$url_mrd <- renderUI({
    tagList("", url_mrd)
  })
  
  # This reactive expression represents the palette function,
  # which changes as the user makes selections in UI.
  colorpal <- reactive({
    colorNumeric(input$colors, datas$ds)
  })
  
  output$map <- renderLeaflet({
    # Use leaflet() here, and only include aspects of the map that
    # won't need to change dynamically (at least, not unless the
    # entire map is being torn down and recreated).
    leaflet(datas) %>% addProviderTiles('Esri.WorldImagery') %>%
      fitBounds(~min(long), ~min(lat), ~max(long), ~max(lat))
  })
  
  output$downloadData <- downloadHandler(
    filename = function() {
      paste("GageLocationComparison", ".csv", sep = "")
    },
    content = function(file) {
      write.csv(datas, file, row.names = FALSE)
    }
  )
  
  #Fitting to the state bounds
  observeEvent(input$map_bounds, {
    loc_ind <- (which (states$north > input$map_bounds$north & states$south < input$map_bounds$south & 
                         states$east < input$map_bounds$east & states$west > input$map_bounds$west 
    ))
    
    loc_out <- (which (states$north < input$map_bounds$north & states$south > input$map_bounds$south & 
                         states$east < input$map_bounds$east & states$west > input$map_bounds$west 
    ))
    
    
    if (length(loc_out) >0){
      datas_new$datas <- datas[which(datas$state %in% states$STUSPS[loc_out]),]
    } else if (length (loc_ind) >0){
      datas_new$datas <- datas[which(datas$state %in% states$STUSPS[loc_ind]),]
    } else {
      datas_new$datas <- datas
    }
  })
  
  # click event
  observeEvent(input$map_marker_click, {
    # click event
    click <- input$map_marker_click
    selectedStringId <- strsplit (click$id, "_")
    selection <- datas_new$datas[which(datas_new$datas$numid %in% selectedStringId[[1]]),]
    
    leafletProxy(mapId = "map") %>%
      clearPopups() %>%
      addPopups(dat = click, lat = ~selection$lat, lng = ~selection$long, popup = selection$id)
  })
  
  # Incremental changes to the map (in this case, replacing the
  # circles when a new color is chosen) should be performed in
  # an observer. Each independent set of things that can change
  # should be managed in its own observer.
  observe({
    pal <- colorpal()
    leafletProxy("map", data = filteredData()) %>%
      clearMarkers() %>%
      addCircleMarkers(radius = ~10, weight = 1, color = "#777777", opacity = 0.5,
                       fillColor = ~pal(ds), fillOpacity = 0.7, layerId = filteredData()$id,
                       popup = ~paste(id)
      )
  })
  
  
  #search bar
  observeEvent (input$search, {
    search_id <- which (datas$numid == input$search)
    if (length (search_id) > 1){
      search_id <- search_id[1]
    }
    lat <-  (datas$lat[search_id])
    long <-  (datas$long[search_id])
    leafletProxy("map") %>%
      setView(lng = long, lat = lat, zoom = 14)
  })
  
  
  # Use a separate observer to recreate the legend as needed.
  observe({
    proxy <- leafletProxy("map", data = datas)
    
    # Remove any existing legend, and only if the legend is
    # enabled, create a new one.
    proxy %>% clearControls()
    if (input$legend) {
      pal <- colorpal()
      proxy %>% addLegend(position = "bottomright",
                          pal = pal, values = ~ds
      )
    }
  })
}

shinyApp(ui, server)